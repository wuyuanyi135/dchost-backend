'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.specialFilters = undefined;
exports.filterSpecials = filterSpecials;
exports.sorter = sorter;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var specialFilters = exports.specialFilters = {
  $in: function $in(key, ins) {
    return function (current) {
      return ins.indexOf(current[key]) !== -1;
    };
  },
  $nin: function $nin(key, nins) {
    return function (current) {
      return nins.indexOf(current[key]) === -1;
    };
  },
  $lt: function $lt(key, value) {
    return function (current) {
      return current[key] < value;
    };
  },
  $lte: function $lte(key, value) {
    return function (current) {
      return current[key] <= value;
    };
  },
  $gt: function $gt(key, value) {
    return function (current) {
      return current[key] > value;
    };
  },
  $gte: function $gte(key, value) {
    return function (current) {
      return current[key] >= value;
    };
  },
  $ne: function $ne(key, value) {
    return function (current) {
      return current[key] !== value;
    };
  }
};

function filterSpecials(values, query) {
  if (query.$or) {
    values = values.filter(function (current) {
      return _lodash2.default.some(query.$or, function (or) {
        return _lodash2.default.isMatch(current, or);
      });
    });
    delete query.$or;
  }

  _lodash2.default.each(query, function (value, key) {
    if (_lodash2.default.isObject(value)) {
      _lodash2.default.each(value, function (target, prop) {
        if (specialFilters[prop]) {
          values = values.filter(specialFilters[prop](key, target));
        }
      });

      delete query[key];
    }
  });

  return values;
}

function sorter($sort) {
  return function (first, second) {
    var comparator = 0;
    _lodash2.default.each($sort, function (modifier, key) {
      modifier = parseInt(modifier, 10);

      if (first[key] < second[key]) {
        comparator -= 1 * modifier;
      }

      if (first[key] > second[key]) {
        comparator += 1 * modifier;
      }
    });
    return comparator;
  };
}